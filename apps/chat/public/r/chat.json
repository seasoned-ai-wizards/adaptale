{
  "name": "chat",
  "type": "registry:ui",
  "registryDependencies": [
    "button",
    "https://shadcn-chatbot-kit.vercel.app/r/use-auto-scroll.json",
    "https://shadcn-chatbot-kit.vercel.app/r/chat-message.json",
    "https://shadcn-chatbot-kit.vercel.app/r/message-input.json",
    "https://shadcn-chatbot-kit.vercel.app/r/message-list.json",
    "https://shadcn-chatbot-kit.vercel.app/r/prompt-suggestions.json"
  ],
  "files": [
    {
      "path": "ui/chat.tsx",
      "content": "\"use client\"\n\nimport {\n  forwardRef,\n  useCallback,\n  useRef,\n  useState,\n  type ReactElement,\n} from \"react\"\nimport { ArrowDown, ThumbsDown, ThumbsUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { useAutoScroll } from \"@/registry/default/hooks/use-auto-scroll\"\nimport { Button } from \"@/registry/default/ui/button\"\nimport { type Message } from \"@/registry/default/ui/chat-message\"\nimport { CopyButton } from \"@/registry/default/ui/copy-button\"\nimport { MessageInput } from \"@/registry/default/ui/message-input\"\nimport { MessageList } from \"@/registry/default/ui/message-list\"\nimport { PromptSuggestions } from \"@/registry/default/ui/prompt-suggestions\"\n\ninterface ChatPropsBase {\n  handleSubmit: (\n    event?: { preventDefault?: () => void },\n    options?: { experimental_attachments?: FileList }\n  ) => void\n  messages: Array<Message>\n  input: string\n  className?: string\n  handleInputChange: React.ChangeEventHandler<HTMLTextAreaElement>\n  isGenerating: boolean\n  stop?: () => void\n  onRateResponse?: (\n    messageId: string,\n    rating: \"thumbs-up\" | \"thumbs-down\"\n  ) => void\n  setMessages?: (messages: any[]) => void\n  transcribeAudio?: (blob: Blob) => Promise<string>\n}\n\ninterface ChatPropsWithoutSuggestions extends ChatPropsBase {\n  append?: never\n  suggestions?: never\n}\n\ninterface ChatPropsWithSuggestions extends ChatPropsBase {\n  append: (message: { role: \"user\"; content: string }) => void\n  suggestions: string[]\n}\n\ntype ChatProps = ChatPropsWithoutSuggestions | ChatPropsWithSuggestions\n\nexport function Chat({\n  messages,\n  handleSubmit,\n  input,\n  handleInputChange,\n  stop,\n  isGenerating,\n  append,\n  suggestions,\n  className,\n  onRateResponse,\n  setMessages,\n  transcribeAudio,\n}: ChatProps) {\n  const lastMessage = messages.at(-1)\n  const isEmpty = messages.length === 0\n  const isTyping = lastMessage?.role === \"user\"\n\n  const messagesRef = useRef(messages)\n  messagesRef.current = messages\n\n  // Enhanced stop function that marks pending tool calls as cancelled\n  const handleStop = useCallback(() => {\n    stop?.()\n\n    if (!setMessages) return\n\n    const latestMessages = [...messagesRef.current]\n    const lastAssistantMessage = latestMessages.findLast(\n      (m) => m.role === \"assistant\"\n    )\n\n    if (!lastAssistantMessage) return\n\n    let needsUpdate = false\n    let updatedMessage = { ...lastAssistantMessage }\n\n    if (lastAssistantMessage.toolInvocations) {\n      const updatedToolInvocations = lastAssistantMessage.toolInvocations.map(\n        (toolInvocation) => {\n          if (toolInvocation.state === \"call\") {\n            needsUpdate = true\n            return {\n              ...toolInvocation,\n              state: \"result\",\n              result: {\n                content: \"Tool execution was cancelled\",\n                __cancelled: true, // Special marker to indicate cancellation\n              },\n            } as const\n          }\n          return toolInvocation\n        }\n      )\n\n      if (needsUpdate) {\n        updatedMessage = {\n          ...updatedMessage,\n          toolInvocations: updatedToolInvocations,\n        }\n      }\n    }\n\n    if (lastAssistantMessage.parts && lastAssistantMessage.parts.length > 0) {\n      const updatedParts = lastAssistantMessage.parts.map((part: any) => {\n        if (\n          part.type === \"tool-invocation\" &&\n          part.toolInvocation &&\n          part.toolInvocation.state === \"call\"\n        ) {\n          needsUpdate = true\n          return {\n            ...part,\n            toolInvocation: {\n              ...part.toolInvocation,\n              state: \"result\",\n              result: {\n                content: \"Tool execution was cancelled\",\n                __cancelled: true,\n              },\n            },\n          }\n        }\n        return part\n      })\n\n      if (needsUpdate) {\n        updatedMessage = {\n          ...updatedMessage,\n          parts: updatedParts,\n        }\n      }\n    }\n\n    if (needsUpdate) {\n      const messageIndex = latestMessages.findIndex(\n        (m) => m.id === lastAssistantMessage.id\n      )\n      if (messageIndex !== -1) {\n        latestMessages[messageIndex] = updatedMessage\n        setMessages(latestMessages)\n      }\n    }\n  }, [stop, setMessages, messagesRef])\n\n  const messageOptions = useCallback(\n    (message: Message) => ({\n      actions: onRateResponse ? (\n        <>\n          <div className=\"border-r pr-1\">\n            <CopyButton\n              content={message.content}\n              copyMessage=\"Copied response to clipboard!\"\n            />\n          </div>\n          <Button\n            size=\"icon\"\n            variant=\"ghost\"\n            className=\"h-6 w-6\"\n            onClick={() => onRateResponse(message.id, \"thumbs-up\")}\n          >\n            <ThumbsUp className=\"h-4 w-4\" />\n          </Button>\n          <Button\n            size=\"icon\"\n            variant=\"ghost\"\n            className=\"h-6 w-6\"\n            onClick={() => onRateResponse(message.id, \"thumbs-down\")}\n          >\n            <ThumbsDown className=\"h-4 w-4\" />\n          </Button>\n        </>\n      ) : (\n        <CopyButton\n          content={message.content}\n          copyMessage=\"Copied response to clipboard!\"\n        />\n      ),\n    }),\n    [onRateResponse]\n  )\n\n  return (\n    <ChatContainer className={className}>\n      {isEmpty && append && suggestions ? (\n        <PromptSuggestions\n          label=\"Try these prompts âœ¨\"\n          append={append}\n          suggestions={suggestions}\n        />\n      ) : null}\n\n      {messages.length > 0 ? (\n        <ChatMessages messages={messages}>\n          <MessageList\n            messages={messages}\n            isTyping={isTyping}\n            messageOptions={messageOptions}\n          />\n        </ChatMessages>\n      ) : null}\n\n      <ChatForm\n        className=\"mt-auto\"\n        isPending={isGenerating || isTyping}\n        handleSubmit={handleSubmit}\n      >\n        {({ files, setFiles }) => (\n          <MessageInput\n            value={input}\n            onChange={handleInputChange}\n            allowAttachments\n            files={files}\n            setFiles={setFiles}\n            stop={handleStop}\n            isGenerating={isGenerating}\n            transcribeAudio={transcribeAudio}\n          />\n        )}\n      </ChatForm>\n    </ChatContainer>\n  )\n}\nChat.displayName = \"Chat\"\n\nexport function ChatMessages({\n  messages,\n  children,\n}: React.PropsWithChildren<{\n  messages: Message[]\n}>) {\n  const {\n    containerRef,\n    scrollToBottom,\n    handleScroll,\n    shouldAutoScroll,\n    handleTouchStart,\n  } = useAutoScroll([messages])\n\n  return (\n    <div\n      className=\"grid grid-cols-1 overflow-y-auto pb-4\"\n      ref={containerRef}\n      onScroll={handleScroll}\n      onTouchStart={handleTouchStart}\n    >\n      <div className=\"max-w-full [grid-column:1/1] [grid-row:1/1]\">\n        {children}\n      </div>\n\n      {!shouldAutoScroll && (\n        <div className=\"pointer-events-none flex flex-1 items-end justify-end [grid-column:1/1] [grid-row:1/1]\">\n          <div className=\"sticky bottom-0 left-0 flex w-full justify-end\">\n            <Button\n              onClick={scrollToBottom}\n              className=\"pointer-events-auto h-8 w-8 rounded-full ease-in-out animate-in fade-in-0 slide-in-from-bottom-1\"\n              size=\"icon\"\n              variant=\"ghost\"\n            >\n              <ArrowDown className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport const ChatContainer = forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"grid max-h-full w-full grid-rows-[1fr_auto]\", className)}\n      {...props}\n    />\n  )\n})\nChatContainer.displayName = \"ChatContainer\"\n\ninterface ChatFormProps {\n  className?: string\n  isPending: boolean\n  handleSubmit: (\n    event?: { preventDefault?: () => void },\n    options?: { experimental_attachments?: FileList }\n  ) => void\n  children: (props: {\n    files: File[] | null\n    setFiles: React.Dispatch<React.SetStateAction<File[] | null>>\n  }) => ReactElement\n}\n\nexport const ChatForm = forwardRef<HTMLFormElement, ChatFormProps>(\n  ({ children, handleSubmit, isPending, className }, ref) => {\n    const [files, setFiles] = useState<File[] | null>(null)\n\n    const onSubmit = (event: React.FormEvent) => {\n      if (!files) {\n        handleSubmit(event)\n        return\n      }\n\n      const fileList = createFileList(files)\n      handleSubmit(event, { experimental_attachments: fileList })\n      setFiles(null)\n    }\n\n    return (\n      <form ref={ref} onSubmit={onSubmit} className={className}>\n        {children({ files, setFiles })}\n      </form>\n    )\n  }\n)\nChatForm.displayName = \"ChatForm\"\n\nfunction createFileList(files: File[] | FileList): FileList {\n  const dataTransfer = new DataTransfer()\n  for (const file of Array.from(files)) {\n    dataTransfer.items.add(file)\n  }\n  return dataTransfer.files\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}
